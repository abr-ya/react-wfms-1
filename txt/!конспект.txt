1-1 Что такое React
https://reactjs.org/
>> A JavaScript library for building user interfaces

Реакт - это библиотека для построения пользовательских интерфейсов.
Реакт построен на компонентах.


1-2 Как работает React (1%)
Try React:
https://reactjs.org/docs/getting-started.html#try-react
*выглядит уже не так, как в курсе


1-3 Что такое компоненты
React-компонент - по сути - это JS-функция


1-4 Create React App
проверить node:
nove -v
*у меня - 10.6.3

npm - node package manager
npm -v
*у меня 6.9.0

установка пакета:
(sudo) npm install -g create-react-app

создание проекта:
create-react-app react-wfms-1

запуск:
npm run start


1-5 Обзор приложения


2-6 Как работает JSX
*примерно с 6 - интересный рассказ про React.createElement()
JSX - по сути, надстройка над этой функцией?


2-7 Ограничения (в JSX)
1) вместо class надо писать className - не забывать!
2) нужно рендерить ОДИН корневой элемент (если надо - завернуть в DIV)


2-8 Inline-стили (3%)


2-9 Создание простого компонента


2-10 Вывод динамических данных (5%)
Для указания на "чистый" JS необходимо часть кода в компоненте взять в фигурные скобки!
Например, можно таким образом вывести результат работы функции Math.

Но в этих скобках нельзя, например, определить класс.


2-11 Передача параметров (5%)
Строку можно передавать просто в кавычках.
Для передачи объекта обязательно использовать фигурные скобки.


2-12 Передача контента (6%)
Для вывода контента, который размещен внутри компонента при его вызове используется свойство:
props.children

Таким образом мы имеем два способа передачи содержимого в компонент.


3-13 Создание State (6%)


3-14 Добавление событий (7%)
События в документации:
https://reactjs.org/docs/events.html#supported-events


3-15 Изменение State (7%)


3-16 Передача параметров в функцию (8%)
Способы передачи:
1) метод bind - более правильно!
2) стрелочная функция


3-17 Обработка Input (9%)


3-18 Работа со списком (9%)
вместо:
-----
<Car name={cars[0].name} year={cars[0].year} onChangeTitle={this.changeTitleHandler.bind(this, cars[0].name)} />
<Car name={cars[1].name} year={cars[1].year} onChangeTitle={() => this.changeTitleHandler(cars[1].name)} />
<Car name={cars[2].name} year={cars[2].year} onChangeTitle={() => this.changeTitleHandler(cars[2].name)} />   
-----
вывод машин в цикле:
-----
        { this.state.cars.map((car) => {
          return (
            <Car
			  key = {index}
              name={car.name}
              year={car.year}
              onChangeTitle={() => this.changeTitleHandler(car.name)}
            />
          )
        }) }
-----


3-19 Работа с условными операторами (10%)
1 способ - использование тернарного оператора прямо в return
2 способ (примернно с 7.00) - классическое условие, но ДО return - в переменную, а переменная в render


3-20 Динамические списки (10%)
https://www.udemy.com/course/reactjswfs/learn/lecture/14740726
*10.50 - начал про удаление элемента
Здесь же неплохой рассказ про контекст, что его нет в стрелочной функции, а значит она может использовать контекст приложения.
И он есть у "классических" функций - поэтому их надо bind-ить!)


4-21 Inline-стили (11%)


4-22 Подключение CSS (11%)


4-23 Динамические классы (12%)
-----
    // это будут классы инпута
    const inputClasses = ['input']

    if (props.name !== '') {
        inputClasses.push('green');
    } else {
        inputClasses.push('red');
    }

    // если длиннее 4х символов
    if (props.name.length > 4) {
        inputClasses.push('bold');
    }
-----
className={inputClasses.join(' ')}
-----


4-24 Radium (12%)
[пока только смотрю]
гит:
https://github.com/FormidableLabs/radium

*3.30 - подключение Radium

После этого можно использовать псевдоселекторы, задавая cтили через JS!


4-25 Препроцессоры (13%)
1) ставим библиотеку:
yarn-add node-sass
2) переименовываем *.css -> *.scss
3) правим импорты

После этого всё должно работать!


4-26 CSS (SCSS) модули
*про использование модулей - хэширование классов
*т.е. делает классы уникальными для компонента!


4-27 Препроцессоры [устарело]
[просто смотрю на 1,5]


4-28 CSS-модули [устарело] (15%)
[просто смотрю на 1,5]


5-29 Передача параметров в компонент (15%)


5-30 Инициализация State (16%)
использование:
constructor(props) {
	super(props) // обязательно!

	// можно:
	this.state = {
		...
	}
}


5-31 Базовый жизненный цикл (31%)
Это этапы, через которые проходит компонент в процессе его определения.
(наследуются от базового компонента)
-----
// компонент готов к рендеру (маунту)
// здесь компонент ещё не готов
  UNSAFE_componentWillMount() {
    console.log('App componentWillMount');
  }

// после рендера компонента
  componentDidMount() {
    console.log('App componentDidMount');
  }
-----
render - может вызываться несколько раз


5-32 Создание Stateful компонента (17%)
"Обычный функциональный компонент" == просто возвращает что-то в методе рендер и больше ничего не делает.

Когда мы создаем компонент, наследуясь от базового класса, это требует больше ресурсов.

Функциональные компоненты == производительность!))


5-33 Жизненный цикл изменения (17%)
[ост. в районе 5.30]
-----
    UNSAFE_componentWillReceiveProps(nextProps) {
        console.log('Car UNSAFE_componentWillReceiveProps', nextProps);
    }

    shouldComponentUpdate(nextProps, nextState) {
        console.log('Car shouldComponentUpdate', nextProps, nextState);
        return true;
    }

    UNSAFE_componentWillUpdate(nextProps, nextState) {
        console.log('Car UNSAFE_ComponentWillUpdate', nextProps, nextState);
    }

    componentDidUpdate() {
        console.log('Car ComponentDidUpdate');
    }
-----
shouldComponentUpdate(nextProps, nextState) - возможность оптимизации!


5-34 Жизненный цикл удаления (18%)
    componentWillUnmount() {
        console.log('Car componentWillUnmount');
    }
-----
Разрушение компонента - его удаление из DOM.


5-35 Жизненные циклы React 16.3+
-----
    UNSAFE_componentWillUpdate(nextProps, nextState) {
        console.log('Car UNSAFE_ComponentWillUpdate', nextProps, nextState);
    }

    // вместо componentWillUpdate
    static getDerivedStateFromProps(nextProps, prevState) {
        console.log('Car getDerivedStateFromProps', nextProps, prevState);

        // возвращаем обновленный (или нет) State
        return prevState
    }
-----
*4.30 - getSnapshotBeforeUpdate() {}
[просто смотрю]
Метод позволяет получить неизмененное DOM-дерево до обновления.


5-36 ErrorBoundary (19%)
Служит для более комфортной обработки ошибок.
[просто смотрю]

Используется для оборачивания компонентов.
Позволяет не ломать работу всего приложения в случае ошибки в отдельном компоненте.


5-37 Фрагменты. Часть 1 (20%)
Начиная с 16-го Реакта компонент может возвращать набор элементов - без корневого тега.
*5.35 - рассмотрим 2 способа избавиться от корневого дива...
1) делать return [] - массив элементов через запятую
но при этом будет warning про key - надо их задать!
2) - в следующем уроке!)


5-38 Фрагменты. Часть 2 (20%)
...
2) в качестве корнего элемента использовать <React.Fragment>
*1.45 - создание своего hoc

есть ещё короткий синтаксис для задания - пустой тег - см. документацию
но он ещё в разработке!))


5-39 Правильное задание State (21%)
Если коротко - использование функции и prevState - защищает от асинхронного изменения Стейта.


5-40 Введение в компоненты высшего порядка (21%)
[просто смотрю]
*чистка заканчивается в районе 2.30
Компоненты высокого порядка добавляют функционал, не изменяя отображение.
*3.50 - пошло создание
Пишет компонент - функцию, который оборачивает переданный компонент в div с переданным классом.


5-41 Валидация параметров с PropTypes (22%)
[просто смотрю]
"Такой некоторый аналог TypeScript."
Надо ставить пакет.

документация:
https://reactjs.org/docs/typechecking-with-proptypes.html


5-42 Референции (23%)
[просто смотрю]


5-43 Context API (23%)
[просто смотрю]
Упрощает работу с прередачей свойств во вложенные компоненты.
Обвертки в виде provider - consumer.


6-44 Создание проекта (24%)

[перехожу к 11]


11-92 Введение


11-93 Как работает Redux (24%)
Redux - это идеология, по которой мы формируем модель данных на фронте!

Библиотека Redux не связана напрямую с реактом!
Она состоит из 3х больших частей:
- Reducer
- Store
- Actions

Идея Redux - в одном JS-объекте содержится всё состояние всего приложения!

Для начала работы нужно создать Store!

Reducer - функция, котороя выполняет некоторое преобразование.
По сути, она преобразует стейт и возвращает новый стейт!
Также принимает объект action. У него есть одно обязательное поле - type.

При создании Store в него передается Reducer (который функция, но не вызывать!).

*7.00 - создаем action - это обычный JS-объект

Проверка type экшена в reducer обычно выполняется с помощью switch - case.
Но для наглядности можно использовать if.

// подписка на изменение store
store.subscribe(() => {
	// что-то
	console.log();
}


11-94 React и Redux (25%)
yarn add react-redux - библиотека для связи Реакта и Ридакса
npm install --save react-redux - установка с добавлением в зависимости!

из этой библиотеки импортируем компонент Provider

*5.50 - подключили провайдер, пошло (надеюсь) внедрение
В rootReducer задаем initial state.


11-95 Подключение компонента (25%)
Для соединения компонента React со Store Redux используется функция connect из библиотеки react-redux.

На вход connect передаются 2 функции:
- mapStateToProps - переносим State (или его часть) в props компонента
- mapDispatchToProps - добавляем функции (обработчики) в props компонента


11-96 Изменение State (26%)
После передачи обработчиков в компоненте вызываем их, например, так.
Было:
-----
          <button onClick={() => this.updateCounter(1)}>Добавить 1</button>
          <button onClick={() => this.updateCounter(-1)}>Вычесть 1</button>
-----
Стало:
-----
          <button onClick={this.props.onAdd}>Добавить 1</button>
          <button onClick={this.props.onSub}>Вычесть 1</button>
-----

После этого пишем логику в reducer для указанных функций.

Важно создавать новый объект, а не менять существующий!
state.counter++; - неправильно!
правильно:
-----
            return {
                counter: state.counter + 1
            }
-----

По сути, с внедрением Redux мы отделяем логику работы компонента от самого компонента!


11-97 Передача параметров (26%)
Передаем стрелочной функцией при объявлении mapDispatchToProps.


11-98 Объединение редюсеров (27%)
[просто смотрю]


11-99 Как работает Middleware (28%)
Это функции, которые дополняют функционал Redux.
[просто смотрю]

В createStore в качестве аргумента передается функция applyMiddleware().
Аргументы этой функции - созданные Middleware.

*5.00 - более элегантная запись с помощью ES-6


11-100 Что такое Action Creator
В этои случае при подготовке connect в dispatch передаётся функция - Creator экшена, описанная в отдельном файле, например - actions.js.
Типы экшенов также выносятся в отельный файл и импортируются, т.к. используются в двух местах:
- в редюсере,
- в Action Creator.


11-101 Асинхронное изменение State (29%)
https://github.com/reduxjs/redux-thunk - библиотека
[наверное просто посмотрю]


11-102 Devtools (29%)
https://github.com/zalmoxisus/redux-devtools-extension - расширения для браузеров - способы установки
Т.к. я не использовал Middleware мне подошёл простой способ.

*6.30 - говорит также про React Dev Tools


12-103 Настройка приложения (30%)
*1.20 "у нас уже есть красивое приложение, которое мы с вами сделали..."
[и тут я решаю идти в раздел 6]


6-44 Создание проекта (30%)
- create-react-app
- yarn eject
- yarn install


6-45 Создание Layout (30%)


6-46 Обновление CSS-модулей
-----
Перед тем как переходить к следующей лекции, убедитесь, что посмотрели обновленный урок по подключению CSS модулей (4 блок лекция 26). Теперь версия create-react-app обновилась с момента записи курса и с модулями стало работать проще.
Теперь eject делать не нужно, достаточно переименовать файл, чтобы он содержал module.
Например  App.module.css 
-----


6-47 Подключение CSS-модулей
*как-то у меня не очень получается - пока просто смотрю*
*иду дальше - у меня вариант без модулей - просто подключаю одноименные файлы*


6-48 Создание главной страницы


6-49 Компонент активного вопроса (33%)
--------------------------------------
В этом месте я решил пересоздать проект без yarn, eject, etc.
Так получился react-quiz2
--------------------------------------
Классы с модулями заработали!


6-50 Список вопросов (33%)
*вроде всё сделал, всё нормально, но у меня опять не обновляется приложение посе изменений*
*например, меняю H1 в Quiz.js, а он меняется только после перезапуска npm!*

*UPD: После перезагрузкт работает! Блуждающая ошибка - всё как я люблю!)*

6-51 Обработка клика (34%)
Долго передаем функцию сверху вниз по компонентам. Наверное с Ридаксом было бы интереснее!)


6-52 Изменение вопроса (34%)


6-53 Отображение состояния ответа (35%)
